\section{Pooling}
\label{sec: pooling}
\cutsection

After training on the labeled data sets and making per-pixel prediction, our system would take the per-pixel's predicted class as input and propose the final location and type of the gesture. We have considered several candidates. First we considered to use mean shift, a similar approach used in \todo{MSR}. However we found that the complexity of mean shift is very high: $O(N^2)$, where N is the number of pixels (in our case $N= 307200$). Then we consider to use clustering, i.e., unsupervised learning. The methodology is as follows: we treat non-background pixels (after per-pixel classification) all equally (without any labels) and then run clustering on them. Then we would use the largest cluster as a proposal of the hand and use the majority of the predicted label as the type of the gesture. The location of the gesture is found by the 2D median of the largest cluster to prevent outliers. In the choice of clustering algorithms, we consider bother K-means and density-based clustering.

\textbf{K-means.} K-means is probably the most commonly used clustering algorithm. A parameter K, the number of clusters, has to be specified beforehand. K-means is fast, with a complexity of $O(2N_{\text{non-background}})$, where $N_{\text{non-background}}$ is the number of non-background pixels. We found that however there is a significant weakness in the application of K-means to our system: (1) K-means assume each cluster has an equal size of points; and (2) K-means is not robust to outliers. As a result, K-means is very likely to divide a hand as two clusters. Therefore we abandon the use of K-means in our system.

\textbf{Density-based clustering.} Density-based cluster is more suitable for graphics application as it tries to cluster points that has a density exceeding pre-determine threshold. We customize the density-based clustering as in Algorithm \todo{DBScan algorithm}. The complexity is O($N_{\text{non-background} }\epsilon^2$), where $\epsilon$ is the radius of the interested pixels that is used in Algorithm 
\todo{DBScan algorithm}.

\begin{algorithm}[t]
%\vskip -0.1in
 \caption{Density-based clustering}
 
\begin{algorithmic}
 \State Input: a depth image with labeled pixels
   \For{each non-background and unvisted pixel $p$}

      \State mark $p$ as visited
         \State neighbor\textunderscore list $\gets$ get\textunderscore neighbors($p$, $\epsilon$ )
         \If{ len(neighbor\textunderscore list) $>$ $\epsilon^2 \times$ density }
            \State add $p$ to a new cluster
            \State create a queue: Seed
            \State enqueue neighbor\textunderscore list to Seed
            \While{Seed not empty}
                \State pixel $t$ $\gets$ Seed.Dequeue()
                \State neighbor\textunderscore list $\gets$ get\textunderscore neighbors($t$, $\epsilon$ )
                \If{len(neighbor\textunderscore list) $>$ $\epsilon^2 \times$ density }
                   \For{each pixel $q$ in neighbor\textunderscore list}
          \If{ $q$ is not visited}                    
                      \State Seed.Enqueue($q$)
                      \State mark $q$ as visited
                      \State add $q$ to the new cluster
                    \EndIf
                   \EndFor 
                \EndIf
            \EndWhile
         \EndIf

  \EndFor
\\
\Function{get\textunderscore neighbors}{$q$, $\epsilon$} 
	\State list is empty	
 	\For{each pixel $x$ that is within $\epsilon$ distance of $q$}
		\If{$x$ is labeled as non-background}
			\State add $x$ into list
		\EndIf 	
 	\EndFor  	
 	\\
 	\Return list
\EndFunction

\end{algorithmic}
\end{algorithm}


